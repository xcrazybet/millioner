<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ô†Ô∏è Professional Poker - XCrazyBet</title>
    
    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Roboto+Mono:wght@300;400&display=swap" rel="stylesheet">
    
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-functions-compat.js"></script>

    <style>
        :root {
            --primary: #ff4081;
            --primary-dark: #d81b60;
            --secondary: #2196f3;
            --success: #4caf50;
            --danger: #ff5252;
            --warning: #ff9800;
            --info: #17a2b8;
            --dark-bg: #0a0a1a;
            --medium-bg: #121230;
            --light-bg: #1a1a3a;
            --table-green: #0a5c36;
            --table-border: #8b4513;
            --text: #ffffff;
            --text-secondary: #b0b0b0;
            --chip-1: #ff4081;
            --chip-5: #2196f3;
            --chip-10: #4caf50;
            --chip-25: #ff9800;
            --chip-100: #9c27b0;
            --chip-500: #f44336;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background: var(--dark-bg);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(255, 64, 129, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 80% 20%, rgba(33, 150, 243, 0.1) 0%, transparent 20%);
        }

        /* Compact Header */
        .header {
            background: rgba(10, 10, 26, 0.95);
            padding: 8px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--primary);
            position: sticky;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
            height: 60px;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.5);
        }

        .logo {
            font-size: 20px;
            font-weight: 700;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo i {
            font-size: 22px;
        }

        .nav-links {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .nav-btn {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: var(--text);
            text-decoration: none;
            font-weight: 500;
            font-size: 13px;
            transition: all 0.2s;
            border: 1px solid transparent;
            white-space: nowrap;
        }

        .nav-btn:hover {
            background: var(--primary);
            transform: translateY(-1px);
        }

        .nav-btn.active {
            background: var(--primary);
            border-color: var(--text);
        }

        .balance-display {
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Main Container */
        .container {
            display: flex;
            max-width: 1800px;
            margin: 0 auto;
            padding: 15px;
            gap: 15px;
            min-height: calc(100vh - 60px);
        }

        /* Sidebar - Compact */
        .sidebar {
            flex: 0 0 280px;
            background: rgba(18, 18, 48, 0.9);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--primary);
            height: fit-content;
            backdrop-filter: blur(5px);
        }

        .sidebar-section {
            margin-bottom: 25px;
        }

        .sidebar h3 {
            color: var(--primary);
            margin-bottom: 12px;
            font-size: 16px;
            border-bottom: 1px solid var(--primary);
            padding-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Player Info Form */
        .player-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .form-group label {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .form-input {
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--light-bg);
            border-radius: 6px;
            color: var(--text);
            font-family: 'Montserrat', sans-serif;
            font-size: 13px;
            transition: all 0.2s;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(255, 64, 129, 0.2);
        }

        .select-wrapper {
            position: relative;
        }

        .select-wrapper select {
            appearance: none;
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--light-bg);
            border-radius: 6px;
            color: var(--text);
            cursor: pointer;
        }

        .select-wrapper::after {
            content: '‚ñº';
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--primary);
            font-size: 10px;
            pointer-events: none;
        }

        /* Top Winners */
        .winners-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .winner-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            transition: all 0.2s;
            font-size: 13px;
        }

        .winner-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(3px);
        }

        .winner-name {
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 140px;
        }

        .winner-amount {
            color: var(--success);
            font-weight: 600;
        }

        /* Table Rules */
        .rules-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            font-size: 12px;
        }

        .rule-item {
            padding: 6px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
            text-align: center;
        }

        .rule-value {
            color: var(--primary);
            font-weight: 600;
            margin-top: 2px;
        }

        /* Main Game Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Poker Table */
        .poker-table-container {
            position: relative;
            flex: 1;
            min-height: 500px;
        }

        .poker-table {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, var(--table-green) 0%, #05422a 70%, #032017 100%);
            border-radius: 300px;
            border: 12px solid var(--table-border);
            box-shadow: 
                0 0 0 8px #654321,
                inset 0 0 60px rgba(0, 0, 0, 0.7),
                0 15px 40px rgba(0, 0, 0, 0.9);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .table-felt {
            position: absolute;
            width: 80%;
            height: 80%;
            background: rgba(10, 92, 54, 0.6);
            border-radius: 50%;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.8);
        }

        .table-center {
            position: absolute;
            width: 35%;
            height: 35%;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            z-index: 2;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .pot-display {
            font-size: 22px;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            padding: 5px 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            border: 2px solid gold;
        }

        .round-display {
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
        }

        .community-cards {
            display: flex;
            gap: 8px;
            margin-top: 5px;
        }

        /* Player Seats - Professional */
        .player-seat {
            position: absolute;
            width: 140px;
            height: 160px;
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 50, 0.9));
            border-radius: 12px;
            border: 2px solid var(--primary);
            padding: 15px;
            text-align: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .player-seat::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            border-radius: 14px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .player-seat.active::before {
            opacity: 1;
        }

        .player-seat.active {
            transform: scale(1.08);
            z-index: 20;
            box-shadow: 0 0 30px rgba(255, 64, 129, 0.6);
        }

        .player-seat.dealer {
            border-color: var(--secondary);
        }

        .player-seat.dealer::after {
            content: 'D';
            position: absolute;
            top: -10px;
            right: -10px;
            width: 20px;
            height: 20px;
            background: var(--secondary);
            border-radius: 50%;
            color: white;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .player-seat.folded {
            opacity: 0.5;
            filter: grayscale(0.7);
        }

        .player-seat.allin {
            border-color: var(--warning);
            animation: pulse 2s infinite;
        }

        .player-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .player-name {
            font-weight: 600;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--text);
        }

        .player-stack {
            color: var(--success);
            font-size: 14px;
            font-weight: 700;
        }

        .player-cards {
            display: flex;
            justify-content: center;
            gap: 6px;
            margin: 8px 0;
        }

        .player-status {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            margin-top: 4px;
        }

        .player-status.folded {
            background: var(--danger);
            color: white;
        }

        .player-status.allin {
            background: var(--warning);
            color: black;
        }

        .player-status.bet {
            background: var(--info);
            color: white;
        }

        /* Card Styles - Professional */
        .card {
            width: 45px;
            height: 65px;
            background: white;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 18px;
            color: black;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            position: relative;
            cursor: pointer;
            user-select: none;
            transform-style: preserve-3d;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .card:hover {
            transform: translateY(-5px) rotateX(5deg);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
        }

        .card.red {
            color: #d50000;
        }

        .card.black {
            color: #000;
        }

        .card.back {
            background: linear-gradient(135deg, var(--primary-dark), var(--secondary));
            color: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .card.back::before {
            content: '‚ô†Ô∏è';
            position: absolute;
            color: rgba(255, 255, 255, 0.8);
            font-size: 24px;
        }

        .card-corner {
            position: absolute;
            font-size: 12px;
            font-weight: bold;
        }

        .card-corner-top {
            top: 4px;
            left: 4px;
        }

        .card-corner-bottom {
            bottom: 4px;
            right: 4px;
            transform: rotate(180deg);
        }

        .card-center {
            font-size: 24px;
            margin-top: 5px;
        }

        /* Action Controls */
        .action-controls {
            background: rgba(0, 0, 0, 0.85);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--primary);
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            backdrop-filter: blur(10px);
        }

        .action-btn {
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .action-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
        }

        .action-btn:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn-fold {
            background: linear-gradient(135deg, var(--danger), #c62828);
            color: white;
        }

        .btn-check {
            background: linear-gradient(135deg, var(--text-secondary), #78909c);
            color: black;
        }

        .btn-call {
            background: linear-gradient(135deg, var(--secondary), #1565c0);
            color: white;
        }

        .btn-raise {
            background: linear-gradient(135deg, var(--warning), #ef6c00);
            color: white;
        }

        .btn-allin {
            background: linear-gradient(135deg, var(--primary), #ad1457);
            color: white;
        }

        .bet-controls {
            grid-column: 1 / -1;
            display: flex;
            gap: 15px;
            align-items: center;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bet-input-container {
            flex: 1;
            position: relative;
        }

        .bet-input {
            width: 100%;
            padding: 14px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--primary);
            border-radius: 8px;
            color: var(--text);
            font-size: 16px;
            font-weight: 600;
            text-align: center;
        }

        .bet-input:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(255, 64, 129, 0.3);
        }

        .chip-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .chip {
            width: 55px;
            height: 55px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
            border: 3px solid white;
            font-size: 14px;
            position: relative;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .chip:hover {
            transform: scale(1.15) rotate(15deg);
        }

        .chip:active {
            transform: scale(0.95);
        }

        .chip::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .chip-1 { background: var(--chip-1); }
        .chip-5 { background: var(--chip-5); }
        .chip-10 { background: var(--chip-10); }
        .chip-25 { background: var(--chip-25); }
        .chip-100 { background: var(--chip-100); }
        .chip-500 { background: var(--chip-500); }

        /* Game Info */
        .game-info {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 12px;
            padding: 18px;
            border: 1px solid var(--secondary);
        }

        .game-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
        }

        .stat-box {
            text-align: center;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .stat-box:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--primary);
        }

        /* Game History */
        .game-history {
            background: rgba(0, 0, 0, 0.9);
            border-radius: 12px;
            padding: 20px;
            margin-top: 15px;
            border: 1px solid var(--primary);
            max-height: 300px;
            overflow-y: auto;
        }

        .history-title {
            color: var(--primary);
            font-size: 16px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .history-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            font-size: 13px;
            transition: all 0.2s;
        }

        .history-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .history-item.win {
            border-left: 4px solid var(--success);
        }

        .history-item.loss {
            border-left: 4px solid var(--danger);
        }

        .history-time {
            color: var(--text-secondary);
            font-size: 11px;
        }

        .history-amount {
            font-weight: 600;
        }

        .history-amount.win {
            color: var(--success);
        }

        .history-amount.loss {
            color: var(--danger);
        }

        /* Connection Status */
        .connection-status {
            position: fixed;
            top: 70px;
            right: 20px;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1000;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .status-connected {
            background: rgba(76, 175, 80, 0.2);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .status-disconnected {
            background: rgba(255, 82, 82, 0.2);
            color: var(--danger);
            border: 1px solid var(--danger);
        }

        /* Game State Overlay */
        .game-state-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border-radius: inherit;
            backdrop-filter: blur(5px);
        }

        .state-message {
            background: rgba(0, 0, 0, 0.9);
            padding: 30px 50px;
            border-radius: 15px;
            border: 2px solid var(--primary);
            text-align: center;
            animation: pulse 2s infinite;
        }

        .state-message h3 {
            color: var(--primary);
            font-size: 24px;
            margin-bottom: 15px;
        }

        .state-message p {
            color: var(--text-secondary);
            font-size: 16px;
        }

        /* Animations */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes chipThrow {
            0% { transform: translateY(0) rotate(0deg) scale(1); }
            50% { transform: translateY(-60px) rotate(180deg) scale(1.2); }
            100% { transform: translateY(0) rotate(360deg) scale(1); }
        }

        @keyframes cardDeal {
            0% { 
                transform: translateY(-100px) rotateY(0deg) scale(0.8); 
                opacity: 0; 
            }
            50% { 
                transform: translateY(-50px) rotateY(180deg) scale(1.1); 
            }
            100% { 
                transform: translateY(0) rotateY(360deg) scale(1); 
                opacity: 1; 
            }
        }

        @keyframes winGlow {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); 
            }
            50% { 
                box-shadow: 0 0 40px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.6); 
            }
        }

        @keyframes lossFade {
            from { 
                background: rgba(255, 82, 82, 0.3); 
            }
            to { 
                background: transparent; 
            }
        }

        .chip-animation {
            animation: chipThrow 1s ease-out;
        }

        .card-deal {
            animation: cardDeal 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .win-glow {
            animation: winGlow 1s ease-in-out infinite;
        }

        .loss-fade {
            animation: lossFade 2s ease-out;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            padding: 15px 20px;
            border-radius: 8px;
            background: rgba(26, 26, 46, 0.95);
            border-left: 4px solid var(--primary);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
            transform: translateX(100%);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            max-width: 350px;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.success { border-color: var(--success); }
        .toast.error { border-color: var(--danger); }
        .toast.warning { border-color: var(--warning); }
        .toast.info { border-color: var(--info); }

        .toast i {
            font-size: 18px;
        }

        /* Loading Spinner */
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
            }
            
            .player-seat {
                width: 120px;
                height: 140px;
                padding: 12px;
            }
            
            .card {
                width: 35px;
                height: 50px;
                font-size: 14px;
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                height: auto;
                padding: 10px;
                gap: 10px;
            }
            
            .nav-links {
                order: 3;
                width: 100%;
                justify-content: center;
            }
            
            .balance-display {
                order: 2;
            }
            
            .logo {
                order: 1;
            }
            
            .action-controls {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .game-stats {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .player-seat {
                width: 100px;
                height: 120px;
                padding: 8px;
                font-size: 11px;
            }
            
            .card {
                width: 30px;
                height: 45px;
                font-size: 12px;
            }
            
            .chip {
                width: 45px;
                height: 45px;
                font-size: 12px;
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-dark);
        }
    </style>
</head>
<body>
    <!-- Compact Header -->
    <header class="header">
        <div class="logo">
            <i class="fas fa-diamond"></i>
            XCrazyBet Poker
        </div>
        
        <nav class="nav-links">
            <a href="https://xcrazybet.github.io/millioner" class="nav-btn">
                <i class="fas fa-home"></i> Home
            </a>
            <a href="https://xcrazybet.github.io/millioner/games.html" class="nav-btn">
                <i class="fas fa-gamepad"></i> Games
            </a>
            <a href="https://xcrazybet.github.io/millioner/bets.html" class="nav-btn">
                <i class="fas fa-coins"></i> Bets
            </a>
            <a href="https://xcrazybet.github.io/millioner/dashboard.html" class="nav-btn">
                <i class="fas fa-wallet"></i> Deposit
            </a>
        </nav>
        
        <div class="balance-display" id="balanceDisplay">
            <i class="fas fa-wallet"></i> Loading...
        </div>
    </header>

    <!-- Connection Status -->
    <div class="connection-status status-connected" id="connectionStatus">
        <i class="fas fa-wifi"></i>
        <span>Connected</span>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Player Info -->
            <div class="sidebar-section">
                <h3><i class="fas fa-user-circle"></i> Player Profile</h3>
                <form class="player-form" id="playerForm">
                    <div class="form-group">
                        <label for="playerName"><i class="fas fa-signature"></i> Display Name</label>
                        <input type="text" id="playerName" class="form-input" 
                               placeholder="Enter your poker name" required
                               value="Player_${Math.floor(Math.random() * 1000)}">
                    </div>
                    
                    <div class="form-group">
                        <label for="playerAge"><i class="fas fa-birthday-cake"></i> Age</label>
                        <input type="number" id="playerAge" class="form-input" 
                               min="18" max="100" value="25" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="playerLevel"><i class="fas fa-trophy"></i> Skill Level</label>
                        <div class="select-wrapper">
                            <select id="playerLevel" class="form-input">
                                <option value="beginner">üü¢ Beginner</option>
                                <option value="intermediate">üü° Intermediate</option>
                                <option value="advanced">üî¥ Advanced</option>
                                <option value="professional">üü£ Professional</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="buyIn"><i class="fas fa-money-bill-wave"></i> Buy-in Amount</label>
                        <input type="number" id="buyIn" class="form-input" 
                               min="10" max="10000" value="500" required>
                    </div>
                    
                    <button type="submit" class="action-btn btn-call" style="margin-top: 5px;">
                        <i class="fas fa-play-circle"></i> Join Poker Table
                    </button>
                </form>
            </div>

            <!-- Top Winners -->
            <div class="sidebar-section">
                <h3><i class="fas fa-crown"></i> Recent Big Wins</h3>
                <div class="winners-list" id="winnersList">
                    <div class="winner-item">
                        <span class="winner-name">Loading...</span>
                        <span class="winner-amount">$0</span>
                    </div>
                </div>
            </div>

            <!-- Table Rules -->
            <div class="sidebar-section">
                <h3><i class="fas fa-gavel"></i> Table Rules</h3>
                <div class="rules-grid">
                    <div class="rule-item">
                        <div>Game</div>
                        <div class="rule-value">Hold'em</div>
                    </div>
                    <div class="rule-item">
                        <div>Blinds</div>
                        <div class="rule-value">$1/$2</div>
                    </div>
                    <div class="rule-item">
                        <div>Players</div>
                        <div class="rule-value">5 Max</div>
                    </div>
                    <div class="rule-item">
                        <div>Rake</div>
                        <div class="rule-value">5%</div>
                    </div>
                    <div class="rule-item">
                        <div>Min Buy</div>
                        <div class="rule-value">$10</div>
                    </div>
                    <div class="rule-item">
                        <div>Max Buy</div>
                        <div class="rule-value">$10K</div>
                    </div>
                    <div class="rule-item">
                        <div>Win Rate</div>
                        <div class="rule-value">10%</div>
                    </div>
                    <div class="rule-item">
                        <div>House Edge</div>
                        <div class="rule-value">90%</div>
                    </div>
                </div>
            </div>

            <!-- Session Limits -->
            <div class="sidebar-section">
                <h3><i class="fas fa-shield-alt"></i> Session Limits</h3>
                <div style="font-size: 12px; color: var(--text-secondary);">
                    <p>‚úì Max 100 hands/day</p>
                    <p>‚úì $1,000 daily loss limit</p>
                    <p>‚úì 5s cooldown between hands</p>
                    <p>‚úì Age 18+ only</p>
                </div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Poker Table -->
            <div class="poker-table-container" id="pokerTableContainer">
                <div class="poker-table" id="pokerTable">
                    <div class="table-felt"></div>
                    
                    <!-- Community Cards -->
                    <div class="table-center">
                        <div class="pot-display" id="potDisplay">Pot: $0</div>
                        <div class="round-display" id="roundDisplay">Pre-flop</div>
                        <div class="community-cards" id="communityCards">
                            <!-- Cards added by JavaScript -->
                        </div>
                    </div>
                    
                    <!-- Player Seats -->
                    <div class="player-seat" id="seat0" style="bottom: 40px; left: 50%; transform: translateX(-50%);">
                        <div class="player-info">
                            <div class="player-name" id="seat0Name">You</div>
                            <div class="player-stack" id="seat0Stack">$0</div>
                        </div>
                        <div class="player-cards" id="seat0Cards"></div>
                        <div class="player-status" id="seat0Status"></div>
                    </div>
                    
                    <div class="player-seat" id="seat1" style="top: 50%; right: 60px; transform: translateY(-50%);">
                        <div class="player-info">
                            <div class="player-name" id="seat1Name">Player 1</div>
                            <div class="player-stack" id="seat1Stack">$100</div>
                        </div>
                        <div class="player-cards" id="seat1Cards"></div>
                        <div class="player-status" id="seat1Status"></div>
                    </div>
                    
                    <div class="player-seat" id="seat2" style="top: 40px; left: 50%; transform: translateX(-50%);">
                        <div class="player-info">
                            <div class="player-name" id="seat2Name">Player 2</div>
                            <div class="player-stack" id="seat2Stack">$100</div>
                        </div>
                        <div class="player-cards" id="seat2Cards"></div>
                        <div class="player-status" id="seat2Status"></div>
                    </div>
                    
                    <div class="player-seat" id="seat3" style="top: 50%; left: 60px; transform: translateY(-50%);">
                        <div class="player-info">
                            <div class="player-name" id="seat3Name">Player 3</div>
                            <div class="player-stack" id="seat3Stack">$100</div>
                        </div>
                        <div class="player-cards" id="seat3Cards"></div>
                        <div class="player-status" id="seat3Status"></div>
                    </div>
                    
                    <div class="player-seat" id="seat4" style="bottom: 120px; right: 120px;">
                        <div class="player-info">
                            <div class="player-name" id="seat4Name">Player 4</div>
                            <div class="player-stack" id="seat4Stack">$100</div>
                        </div>
                        <div class="player-cards" id="seat4Cards"></div>
                        <div class="player-status" id="seat4Status"></div>
                    </div>
                </div>

                <!-- Game State Overlay -->
                <div class="game-state-overlay" id="gameStateOverlay" style="display: none;">
                    <div class="state-message" id="stateMessage">
                        <h3>Game Loading...</h3>
                        <p>Please wait while we set up your table</p>
                        <div class="spinner" style="margin: 20px auto;"></div>
                    </div>
                </div>
            </div>

            <!-- Action Controls -->
            <div class="action-controls" id="actionControls" style="display: none;">
                <button class="action-btn btn-fold" id="btnFold">
                    <i class="fas fa-times"></i> Fold
                </button>
                <button class="action-btn btn-check" id="btnCheck">
                    <i class="fas fa-check"></i> Check
                </button>
                <button class="action-btn btn-call" id="btnCall">
                    <i class="fas fa-handshake"></i> Call $0
                </button>
                <button class="action-btn btn-raise" id="btnRaise">
                    <i class="fas fa-arrow-up"></i> Raise
                </button>
                <button class="action-btn btn-allin" id="btnAllIn">
                    <i class="fas fa-fire"></i> All In
                </button>
                
                <div class="bet-controls">
                    <div class="bet-input-container">
                        <input type="number" class="bet-input" id="betAmount" value="0" min="0" placeholder="Enter bet amount">
                    </div>
                    <div class="chip-selector">
                        <div class="chip chip-1" data-amount="1">$1</div>
                        <div class="chip chip-5" data-amount="5">$5</div>
                        <div class="chip chip-10" data-amount="10">$10</div>
                        <div class="chip chip-25" data-amount="25">$25</div>
                        <div class="chip chip-100" data-amount="100">$100</div>
                        <div class="chip chip-500" data-amount="500">$500</div>
                    </div>
                </div>
            </div>

            <!-- Game Stats -->
            <div class="game-info">
                <h3 style="color: var(--primary); margin-bottom: 15px;">
                    <i class="fas fa-chart-bar"></i> Game Statistics
                </h3>
                <div class="game-stats">
                    <div class="stat-box">
                        <div class="stat-label">Win Rate</div>
                        <div class="stat-value" id="winRate">10%</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Total Hands</div>
                        <div class="stat-value" id="totalHands">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Net Profit</div>
                        <div class="stat-value" id="netProfit">$0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Session Time</div>
                        <div class="stat-value" id="sessionTime">0m</div>
                    </div>
                </div>
            </div>

            <!-- Game History -->
            <div class="game-history">
                <div class="history-title">
                    <i class="fas fa-history"></i> Hand History
                </div>
                <div class="history-list" id="historyList">
                    <div class="history-item">
                        <span>Welcome to XCrazyBet Poker!</span>
                        <span class="history-time">Now</span>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Firebase Cloud Functions would go here -->
    <script>
        // ===== FIREBASE CONFIGURATION =====
        const firebaseConfig = {
            apiKey: "AIzaSyA72Yo_YGqno9PX25p3yQBvyflcaM-NqEM",
            authDomain: "x-bet-prod-jd.firebaseapp.com",
            projectId: "x-bet-prod-jd",
            storageBucket: "x-bet-prod-jd.firebasestorage.app",
            messagingSenderId: "499334334535",
            appId: "1:499334334535:web:bebc1bf817e24d9e3c4962"
        };

        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const functions = firebase.functions();

        // ===== GAME STATE MANAGEMENT =====
        class PokerGame {
            constructor() {
                this.currentUser = null;
                this.gameId = null;
                this.playerId = null;
                this.gameState = {
                    status: 'waiting', // waiting, preflop, flop, turn, river, showdown, ended
                    players: [],
                    deck: [],
                    communityCards: [],
                    pot: 0,
                    dealerPosition: 0,
                    currentPlayer: null,
                    currentBet: 0,
                    round: 'preflop',
                    winners: [],
                    rake: 0,
                    timestamp: null
                };
                this.playerProfile = null;
                this.balance = 0;
                this.session = {
                    startTime: null,
                    handsPlayed: 0,
                    handsWon: 0,
                    netProfit: 0,
                    dailyLimit: 100,
                    dailyLossLimit: 1000,
                    lastActionTime: null
                };
                this.gameHistory = [];
                this.recentWinners = [];
                this.aiPlayers = [];
                this.connectionStatus = 'connected';
                this.isProcessing = false;
                this.actionLock = false;
                this.gameConfig = {
                    winRate: 0.10, // 10% win rate
                    houseEdge: 0.90, // 90% house edge
                    minBet: 1,
                    maxBet: 10000,
                    blinds: { small: 1, big: 2 },
                    rakePercentage: 0.05, // 5% rake
                    maxRake: 10
                };
            }

            // ===== INITIALIZATION =====
            async init() {
                try {
                    await this.checkAuth();
                    await this.loadConfig();
                    await this.loadBalance();
                    await this.loadRecentWinners();
                    await this.loadGameHistory();
                    this.setupEventListeners();
                    this.startSessionTimer();
                    this.setupConnectionMonitoring();
                    this.logGameEvent('system', 'Game initialized');
                } catch (error) {
                    console.error('Initialization error:', error);
                    this.showToast('Failed to initialize game', 'error');
                }
            }

            // ===== AUTHENTICATION =====
            async checkAuth() {
                return new Promise((resolve, reject) => {
                    auth.onAuthStateChanged(async (user) => {
                        if (!user) {
                            this.showToast('Please login to play', 'error');
                            setTimeout(() => {
                                window.location.href = 'login.html';
                            }, 2000);
                            reject(new Error('Not authenticated'));
                            return;
                        }
                        this.currentUser = user;
                        this.playerId = user.uid;
                        this.logGameEvent('auth', 'User authenticated');
                        resolve();
                    });
                });
            }

            // ===== CONFIGURATION MANAGEMENT =====
            async loadConfig() {
                try {
                    const configDoc = await db.collection('config').doc('poker').get();
                    if (configDoc.exists) {
                        const config = configDoc.data();
                        this.gameConfig = { ...this.gameConfig, ...config };
                        this.logGameEvent('config', 'Game configuration loaded');
                    }
                } catch (error) {
                    console.error('Error loading config:', error);
                    // Use default config
                }
            }

            // ===== BALANCE MANAGEMENT =====
            async loadBalance() {
                try {
                    const doc = await db.collection("wallets").doc(this.currentUser.uid).get();
                    if (doc.exists) {
                        this.balance = doc.data().balance || 0;
                        this.updateBalanceDisplay();
                    }
                } catch (error) {
                    console.error('Error loading balance:', error);
                    this.showToast('Error loading balance', 'error');
                }
            }

            updateBalanceDisplay() {
                const element = document.getElementById('balanceDisplay');
                if (element) {
                    element.innerHTML = `<i class="fas fa-wallet"></i> $${this.balance.toFixed(2)}`;
                }
            }

            // ===== GAME HISTORY =====
            async loadGameHistory() {
                try {
                    const snapshot = await db.collection('poker_history')
                        .where('playerId', '==', this.currentUser.uid)
                        .orderBy('timestamp', 'desc')
                        .limit(20)
                        .get();
                    
                    this.gameHistory = [];
                    snapshot.forEach(doc => {
                        this.gameHistory.push({ id: doc.id, ...doc.data() });
                    });
                    this.updateHistoryDisplay();
                } catch (error) {
                    console.error('Error loading history:', error);
                }
            }

            updateHistoryDisplay() {
                const container = document.getElementById('historyList');
                if (!container) return;
                
                container.innerHTML = '';
                
                if (this.gameHistory.length === 0) {
                    container.innerHTML = '<div class="history-item">No games played yet</div>';
                    return;
                }
                
                this.gameHistory.forEach(record => {
                    const item = document.createElement('div');
                    item.className = `history-item ${record.result}`;
                    
                    const time = record.timestamp?.toDate ? 
                        this.formatTime(record.timestamp.toDate()) : 
                        this.formatTime(new Date());
                    
                    item.innerHTML = `
                        <div>
                            <div>${record.description || 'Poker Hand'}</div>
                            <div style="font-size: 11px; color: var(--text-secondary);">${record.handId || ''}</div>
                        </div>
                        <div>
                            <span class="history-amount ${record.result}">
                                ${record.result === 'win' ? '+' : ''}$${Math.abs(record.amount || 0)}
                            </span>
                            <div class="history-time">${time}</div>
                        </div>
                    `;
                    container.appendChild(item);
                });
            }

            // ===== RECENT WINNERS =====
            async loadRecentWinners() {
                try {
                    const tenDaysAgo = new Date();
                    tenDaysAgo.setDate(tenDaysAgo.getDate() - 10);
                    
                    const snapshot = await db.collection('poker_wins')
                        .where('timestamp', '>=', tenDaysAgo)
                        .orderBy('timestamp', 'desc')
                        .limit(10)
                        .get();
                    
                    this.recentWinners = [];
                    snapshot.forEach(doc => {
                        this.recentWinners.push(doc.data());
                    });
                    this.updateWinnersDisplay();
                } catch (error) {
                    console.error('Error loading winners:', error);
                }
            }

            updateWinnersDisplay() {
                const container = document.getElementById('winnersList');
                if (!container) return;
                
                container.innerHTML = '';
                
                if (this.recentWinners.length === 0) {
                    container.innerHTML = '<div class="winner-item"><span>No recent winners</span></div>';
                    return;
                }
                
                this.recentWinners.forEach(winner => {
                    const item = document.createElement('div');
                    item.className = 'winner-item';
                    item.innerHTML = `
                        <span class="winner-name">${winner.player}</span>
                        <span class="winner-amount">$${winner.amount}</span>
                    `;
                    container.appendChild(item);
                });
            }

            // ===== PLAYER PROFILE =====
            async joinGame() {
                if (this.isProcessing) {
                    this.showToast('Please wait...', 'warning');
                    return;
                }

                const playerName = document.getElementById('playerName').value.trim();
                const playerAge = parseInt(document.getElementById('playerAge').value);
                const playerLevel = document.getElementById('playerLevel').value;
                const buyIn = parseInt(document.getElementById('buyIn').value);

                // Validation
                if (!playerName || playerName.length < 3) {
                    this.showToast('Enter a valid name (min 3 chars)', 'error');
                    return;
                }

                if (playerAge < 18) {
                    this.showToast('You must be 18+ to play', 'error');
                    return;
                }

                if (buyIn < this.gameConfig.minBet || buyIn > this.gameConfig.maxBet) {
                    this.showToast(`Buy-in must be between $${this.gameConfig.minBet} and $${this.gameConfig.maxBet}`, 'error');
                    return;
                }

                if (buyIn > this.balance) {
                    this.showToast('Insufficient balance', 'error');
                    return;
                }

                // Check daily limits
                const dailyStats = await this.getDailyStats();
                if (dailyStats.handsPlayed >= this.session.dailyLimit) {
                    this.showToast('Daily hand limit reached', 'error');
                    return;
                }

                if (dailyStats.dailyLoss >= this.session.dailyLossLimit) {
                    this.showToast('Daily loss limit reached', 'error');
                    return;
                }

                this.isProcessing = true;
                this.showGameState('Setting up table...');

                try {
                    // Deduct buy-in via Cloud Function for security
                    const deductBalance = functions.httpsCallable('deductPokerBuyIn');
                    const result = await deductBalance({
                        amount: buyIn,
                        playerName: playerName,
                        gameType: 'poker'
                    });

                    if (result.data.success) {
                        this.balance = result.data.newBalance;
                        this.updateBalanceDisplay();
                        
                        // Create player profile
                        this.playerProfile = {
                            id: this.playerId,
                            name: playerName,
                            age: playerAge,
                            level: playerLevel,
                            stack: buyIn,
                            position: 0,
                            isAI: false,
                            cards: [],
                            isActive: true,
                            isFolded: false,
                            currentBet: 0,
                            isAllIn: false,
                            hasActed: false
                        };

                        // Generate AI players
                        await this.generateAIPlayers();

                        // Initialize game
                        await this.initializeGame();

                        this.showToast('Welcome to the table!', 'success');
                        this.logGameEvent('join', `Joined table with $${buyIn} buy-in`);
                    } else {
                        throw new Error(result.data.error || 'Failed to deduct balance');
                    }
                } catch (error) {
                    console.error('Join game error:', error);
                    this.showToast(error.message || 'Failed to join game', 'error');
                } finally {
                    this.isProcessing = false;
                    this.hideGameState();
                }
            }

            // ===== AI PLAYER GENERATION =====
            async generateAIPlayers() {
                const aiNames = [
                    "Ace_High", "BluffMaster", "CardShark", "PokerFace", "RoyalFlush",
                    "All_In_Andy", "ChipLeader", "DealerDave", "FoldKing", "RiverRat"
                ];
                
                this.aiPlayers = [];
                const usedNames = new Set([this.playerProfile.name]);

                for (let i = 1; i <= 4; i++) {
                    let name;
                    do {
                        name = aiNames[Math.floor(Math.random() * aiNames.length)];
                    } while (usedNames.has(name));
                    usedNames.add(name);

                    const stack = Math.floor(Math.random() * (5000 - 200 + 1)) + 200;
                    const aiStyle = Math.random() > 0.5 ? 'aggressive' : 'conservative';
                    
                    this.aiPlayers.push({
                        id: `ai_${i}_${Date.now()}`,
                        name: name,
                        stack: stack,
                        position: i,
                        isAI: true,
                        cards: [],
                        isActive: true,
                        isFolded: false,
                        currentBet: 0,
                        isAllIn: false,
                        hasActed: false,
                        aiStyle: aiStyle,
                        aiSkill: Math.random() * 0.7 + 0.3 // 0.3 to 1.0 skill level
                    });
                }
            }

            // ===== GAME INITIALIZATION =====
            async initializeGame() {
                this.gameId = `poker_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                // Combine players
                this.gameState.players = [this.playerProfile, ...this.aiPlayers];
                this.gameState.status = 'waiting';
                this.gameState.deck = this.createDeck();
                this.gameState.communityCards = [];
                this.gameState.pot = 0;
                this.gameState.currentBet = 0;
                this.gameState.round = 'preflop';
                this.gameState.timestamp = new Date();

                // Update UI
                this.updatePlayerDisplays();
                document.getElementById('actionControls').style.display = 'grid';
                
                // Start the game
                setTimeout(() => this.startNewHand(), 1000);
            }

            // ===== DECK MANAGEMENT =====
            createDeck() {
                const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
                const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
                const deck = [];
                
                for (const suit of suits) {
                    for (const rank of ranks) {
                        deck.push({
                            rank,
                            suit,
                            color: suit === '‚ô•' || suit === '‚ô¶' ? 'red' : 'black',
                            value: this.getCardValue(rank)
                        });
                    }
                }
                
                return this.shuffleDeck(deck);
            }

            shuffleDeck(deck) {
                // Fisher-Yates shuffle with cryptographic randomness
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(this.getSecureRandom() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
                return deck;
            }

            getSecureRandom() {
                // Combine multiple sources for better randomness
                const crypto = window.crypto || window.msCrypto;
                if (crypto && crypto.getRandomValues) {
                    const array = new Uint32Array(1);
                    crypto.getRandomValues(array);
                    return array[0] / (0xFFFFFFFF + 1);
                }
                return Math.random();
            }

            getCardValue(rank) {
                const values = {
                    '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
                    'J': 11, 'Q': 12, 'K': 13, 'A': 14
                };
                return values[rank] || 0;
            }

            // ===== GAME FLOW =====
            async startNewHand() {
                if (this.isProcessing) return;
                
                this.isProcessing = true;
                this.showGameState('Starting new hand...');
                
                try {
                    // Check session limits
                    if (this.session.handsPlayed >= this.session.dailyLimit) {
                        this.showToast('Daily hand limit reached', 'warning');
                        this.endSession();
                        return;
                    }

                    // Reset game state
                    this.gameState.deck = this.createDeck();
                    this.gameState.communityCards = [];
                    this.gameState.pot = 0;
                    this.gameState.currentBet = 0;
                    this.gameState.round = 'preflop';
                    this.gameState.winners = [];
                    
                    // Reset player states
                    this.gameState.players.forEach(player => {
                        player.cards = [];
                        player.isFolded = false;
                        player.currentBet = 0;
                        player.isAllIn = false;
                        player.hasActed = false;
                    });

                    // Rotate dealer
                    this.gameState.dealerPosition = (this.gameState.dealerPosition + 1) % 5;
                    
                    // Deal cards
                    await this.dealCards();
                    
                    // Post blinds
                    await this.postBlinds();
                    
                    // Update UI
                    this.updateAllDisplays();
                    
                    // Start betting round
                    setTimeout(() => {
                        this.startBettingRound();
                        this.isProcessing = false;
                        this.hideGameState();
                    }, 1500);
                    
                    this.session.handsPlayed++;
                    this.updateSessionDisplay();
                    this.logGameEvent('hand_start', `Hand #${this.session.handsPlayed} started`);
                    
                } catch (error) {
                    console.error('Error starting new hand:', error);
                    this.showToast('Error starting hand', 'error');
                    this.isProcessing = false;
                    this.hideGameState();
                }
            }

            async dealCards() {
                // Deal two cards to each player
                for (let i = 0; i < 2; i++) {
                    for (const player of this.gameState.players) {
                        if (player.isActive) {
                            const card = this.gameState.deck.pop();
                            player.cards.push(card);
                            
                            // Animate card deal
                            this.animateCardDeal(player.position);
                        }
                    }
                    await this.sleep(300);
                }
            }

            async postBlinds() {
                const smallBlindPos = (this.gameState.dealerPosition + 1) % 5;
                const bigBlindPos = (this.gameState.dealerPosition + 2) % 5;
                
                const sbPlayer = this.gameState.players[smallBlindPos];
                const bbPlayer = this.gameState.players[bigBlindPos];
                
                // Post small blind
                const sbAmount = Math.min(this.gameConfig.blinds.small, sbPlayer.stack);
                sbPlayer.currentBet = sbAmount;
                sbPlayer.stack -= sbAmount;
                this.gameState.pot += sbAmount;
                
                // Post big blind
                const bbAmount = Math.min(this.gameConfig.blinds.big, bbPlayer.stack);
                bbPlayer.currentBet = bbAmount;
                bbPlayer.stack -= bbAmount;
                this.gameState.pot += bbAmount;
                this.gameState.currentBet = bbAmount;
                
                this.showToast(`${sbPlayer.name} posts small blind $${sbAmount}`, 'info');
                this.showToast(`${bbPlayer.name} posts big blind $${bbAmount}`, 'info');
                
                // Set first player to act (after big blind)
                const firstPlayerPos = (this.gameState.dealerPosition + 3) % 5;
                this.gameState.currentPlayer = this.gameState.players[firstPlayerPos].id;
            }

            startBettingRound() {
                this.gameState.players.forEach(player => {
                    player.hasActed = false;
                });
                
                // Enable player actions if it's their turn
                const currentPlayer = this.gameState.players.find(p => p.id === this.gameState.currentPlayer);
                if (currentPlayer && !currentPlayer.isAI) {
                    this.enablePlayerActions();
                } else {
                    this.disablePlayerActions();
                    // Start AI actions
                    setTimeout(() => this.processAIActions(), 1000);
                }
                
                this.updateAllDisplays();
                this.logGameEvent('betting_round', `${this.gameState.round} betting started`);
            }

            // ===== PLAYER ACTIONS =====
            enablePlayerActions() {
                if (this.actionLock) return;
                
                const player = this.getCurrentPlayer();
                if (!player || player.isAI) return;
                
                const callAmount = this.getCallAmount(player);
                const canCheck = callAmount === 0;
                
                document.getElementById('btnFold').disabled = false;
                document.getElementById('btnCheck').disabled = !canCheck;
                document.getElementById('btnCall').disabled = callAmount === 0;
                document.getElementById('btnRaise').disabled = false;
                document.getElementById('btnAllIn').disabled = false;
                
                if (callAmount > 0) {
                    document.getElementById('btnCall').innerHTML = 
                        `<i class="fas fa-handshake"></i> Call $${callAmount}`;
                }
                
                // Set minimum raise
                const minRaise = Math.max(callAmount * 2, this.gameConfig.blinds.big * 2);
                document.getElementById('betAmount').value = minRaise;
                document.getElementById('betAmount').min = minRaise;
                
                this.showToast(`Your turn to act (${this.gameState.round})`, 'info');
            }

            disablePlayerActions() {
                document.getElementById('btnFold').disabled = true;
                document.getElementById('btnCheck').disabled = true;
                document.getElementById('btnCall').disabled = true;
                document.getElementById('btnRaise').disabled = true;
                document.getElementById('btnAllIn').disabled = true;
            }

            async playerAction(action) {
                if (this.actionLock || this.isProcessing) return;
                
                const player = this.getCurrentPlayer();
                if (!player || player.isAI || player.id !== this.playerId) return;
                
                this.actionLock = true;
                this.disablePlayerActions();
                
                try {
                    let amount = 0;
                    let actionTaken = false;
                    
                    switch (action) {
                        case 'fold':
                            player.isFolded = true;
                            this.showToast(`${player.name} folds`, 'info');
                            actionTaken = true;
                            this.logGameAction(player, 'fold', 0);
                            break;
                            
                        case 'check':
                            if (this.getCallAmount(player) > 0) {
                                this.showToast('Cannot check, must call or fold', 'warning');
                                this.actionLock = false;
                                this.enablePlayerActions();
                                return;
                            }
                            this.showToast(`${player.name} checks`, 'info');
                            actionTaken = true;
                            this.logGameAction(player, 'check', 0);
                            break;
                            
                        case 'call':
                            amount = this.getCallAmount(player);
                            if (amount === 0) {
                                this.showToast('Nothing to call', 'warning');
                                this.actionLock = false;
                                this.enablePlayerActions();
                                return;
                            }
                            
                            const callAmount = Math.min(amount, player.stack);
                            player.currentBet += callAmount;
                            player.stack -= callAmount;
                            this.gameState.pot += callAmount;
                            
                            if (player.stack === 0) {
                                player.isAllIn = true;
                                this.showToast(`${player.name} calls all-in for $${callAmount}!`, 'warning');
                            } else {
                                this.showToast(`${player.name} calls $${callAmount}`, 'info');
                            }
                            
                            actionTaken = true;
                            this.logGameAction(player, 'call', callAmount);
                            break;
                            
                        case 'raise':
                            amount = parseInt(document.getElementById('betAmount').value);
                            if (isNaN(amount) || amount < this.getCallAmount(player) * 2) {
                                const minRaise = this.getCallAmount(player) * 2;
                                this.showToast(`Minimum raise is $${minRaise}`, 'warning');
                                this.actionLock = false;
                                this.enablePlayerActions();
                                return;
                            }
                            
                            if (amount > player.stack) {
                                amount = player.stack;
                            }
                            
                            const totalBet = player.currentBet + amount;
                            if (totalBet <= this.gameState.currentBet) {
                                this.showToast(`Raise must be higher than current bet ($${this.gameState.currentBet})`, 'warning');
                                this.actionLock = false;
                                this.enablePlayerActions();
                                return;
                            }
                            
                            player.currentBet = totalBet;
                            player.stack -= amount;
                            this.gameState.pot += amount;
                            this.gameState.currentBet = totalBet;
                            
                            if (player.stack === 0) {
                                player.isAllIn = true;
                                this.showToast(`${player.name} raises all-in to $${totalBet}!`, 'warning');
                            } else {
                                this.showToast(`${player.name} raises to $${totalBet}`, 'info');
                            }
                            
                            actionTaken = true;
                            this.logGameAction(player, 'raise', amount);
                            break;
                            
                        case 'allin':
                            amount = player.stack;
                            player.currentBet += amount;
                            player.stack = 0;
                            this.gameState.pot += amount;
                            player.isAllIn = true;
                            
                            if (player.currentBet > this.gameState.currentBet) {
                                this.gameState.currentBet = player.currentBet;
                            }
                            
                            this.showToast(`${player.name} goes ALL-IN for $${amount}!`, 'warning');
                            actionTaken = true;
                            this.logGameAction(player, 'allin', amount);
                            break;
                    }
                    
                    if (actionTaken) {
                        player.hasActed = true;
                        this.updateAllDisplays();
                        
                        // Check if betting round is complete
                        if (this.isBettingRoundComplete()) {
                            this.advanceGame();
                        } else {
                            this.advanceToNextPlayer();
                        }
                    }
                    
                } catch (error) {
                    console.error('Player action error:', error);
                    this.showToast('Action failed', 'error');
                } finally {
                    this.actionLock = false;
                }
            }

            getCallAmount(player) {
                return Math.max(0, this.gameState.currentBet - player.currentBet);
            }

            getCurrentPlayer() {
                return this.gameState.players.find(p => p.id === this.gameState.currentPlayer);
            }

            // ===== AI ACTIONS =====
            async processAIActions() {
                const player = this.getCurrentPlayer();
                if (!player || !player.isAI || player.isFolded || player.isAllIn) {
                    this.advanceToNextPlayer();
                    return;
                }
                
                // AI thinking delay
                await this.sleep(1000 + Math.random() * 2000);
                
                const callAmount = this.getCallAmount(player);
                const decision = this.makeAIDecision(player, callAmount);
                
                switch (decision.action) {
                    case 'fold':
                        player.isFolded = true;
                        this.showToast(`${player.name} folds`, 'info');
                        this.logGameAction(player, 'fold', 0);
                        break;
                        
                    case 'check':
                        if (callAmount > 0) {
                            // Can't check when there's a bet, so call instead
                            const callAmountActual = Math.min(callAmount, player.stack);
                            player.currentBet += callAmountActual;
                            player.stack -= callAmountActual;
                            this.gameState.pot += callAmountActual;
                            
                            if (player.stack === 0) player.isAllIn = true;
                            this.showToast(`${player.name} calls $${callAmountActual}`, 'info');
                            this.logGameAction(player, 'call', callAmountActual);
                        } else {
                            this.showToast(`${player.name} checks`, 'info');
                            this.logGameAction(player, 'check', 0);
                        }
                        break;
                        
                    case 'call':
                        const callAmountActual = Math.min(callAmount, player.stack);
                        player.currentBet += callAmountActual;
                        player.stack -= callAmountActual;
                        this.gameState.pot += callAmountActual;
                        
                        if (player.stack === 0) player.isAllIn = true;
                        this.showToast(`${player.name} calls $${callAmountActual}`, 'info');
                        this.logGameAction(player, 'call', callAmountActual);
                        break;
                        
                    case 'raise':
                        const raiseAmount = Math.min(decision.amount, player.stack);
                        player.currentBet += raiseAmount;
                        player.stack -= raiseAmount;
                        this.gameState.pot += raiseAmount;
                        
                        if (player.currentBet > this.gameState.currentBet) {
                            this.gameState.currentBet = player.currentBet;
                        }
                        
                        if (player.stack === 0) player.isAllIn = true;
                        this.showToast(`${player.name} raises to $${player.currentBet}`, 'info');
                        this.logGameAction(player, 'raise', raiseAmount);
                        break;
                }
                
                player.hasActed = true;
                this.updateAllDisplays();
                
                // Check if betting round is complete
                if (this.isBettingRoundComplete()) {
                    this.advanceGame();
                } else {
                    this.advanceToNextPlayer();
                }
            }

            makeAIDecision(player, callAmount) {
                const handStrength = this.evaluateHandStrength(player);
                const potOdds = callAmount / (this.gameState.pot + callAmount);
                const randomFactor = Math.random();
                
                let action = 'fold';
                let amount = 0;
                
                // Adjust based on AI style
                let aggression = player.aiStyle === 'aggressive' ? 0.7 : 0.3;
                aggression *= player.aiSkill; // Scale by skill level
                
                if (player.isAllIn) {
                    return { action: 'check', amount: 0 };
                }
                
                if (handStrength > 0.8) { // Strong hand
                    if (randomFactor < 0.8) {
                        action = 'raise';
                        amount = Math.min(
                            player.stack * 0.5,
                            this.gameState.currentBet * 2 + Math.random() * 100
                        );
                    } else {
                        action = 'call';
                    }
                } else if (handStrength > 0.5) { // Medium hand
                    if (potOdds < 0.3 && randomFactor < aggression) {
                        action = 'raise';
                        amount = Math.min(player.stack * 0.3, callAmount * 2);
                    } else if (callAmount < player.stack * 0.2) {
                        action = 'call';
                    } else {
                        action = randomFactor < 0.3 ? 'fold' : 'call';
                    }
                } else { // Weak hand
                    if (callAmount === 0) {
                        action = randomFactor < aggression * 0.5 ? 'raise' : 'check';
                        if (action === 'raise') {
                            amount = Math.min(player.stack * 0.2, this.gameConfig.blinds.big * 2);
                        }
                    } else if (callAmount < player.stack * 0.1 && randomFactor < 0.4) {
                        action = 'call';
                    } else {
                        action = 'fold';
                    }
                }
                
                return { action, amount };
            }

            evaluateHandStrength(player) {
                // Simple hand strength evaluation
                const cards = [...player.cards, ...this.gameState.communityCards];
                if (cards.length < 2) return 0.5;
                
                let strength = 0;
                
                // High card value
                const highCard = Math.max(...player.cards.map(c => c.value));
                strength += highCard / 14 * 0.3;
                
                // Pair possibility
                const ranks = cards.map(c => c.rank);
                const uniqueRanks = new Set(ranks);
                const pairCount = ranks.length - uniqueRanks.size;
                strength += (pairCount * 0.2);
                
                // Suited cards
                if (player.cards.length === 2) {
                    if (player.cards[0].suit === player.cards[1].suit) {
                        strength += 0.1;
                    }
                    
                    // Connected cards
                    const cardDiff = Math.abs(player.cards[0].value - player.cards[1].value);
                    if (cardDiff <= 2) {
                        strength += 0.1;
                    }
                }
                
                return Math.min(strength, 1);
            }

            // ===== GAME PROGRESSION =====
            advanceToNextPlayer() {
                let currentIndex = this.gameState.players.findIndex(p => p.id === this.gameState.currentPlayer);
                let attempts = 0;
                
                while (attempts < this.gameState.players.length) {
                    currentIndex = (currentIndex + 1) % this.gameState.players.length;
                    const nextPlayer = this.gameState.players[currentIndex];
                    
                    if (nextPlayer.isActive && !nextPlayer.isFolded && !nextPlayer.isAllIn) {
                        this.gameState.currentPlayer = nextPlayer.id;
                        
                        if (nextPlayer.isAI) {
                            this.disablePlayerActions();
                            setTimeout(() => this.processAIActions(), 500);
                        } else {
                            this.enablePlayerActions();
                        }
                        
                        this.updateAllDisplays();
                        return;
                    }
                    
                    attempts++;
                }
                
                // If we get here, betting round might be complete
                if (this.isBettingRoundComplete()) {
                    this.advanceGame();
                }
            }

            isBettingRoundComplete() {
                const activePlayers = this.gameState.players.filter(p => 
                    p.isActive && !p.isFolded && !p.isAllIn
                );
                
                if (activePlayers.length <= 1) return true;
                
                const allActed = activePlayers.every(p => p.hasActed || p.isAllIn);
                const allEqualized = activePlayers.every(p => 
                    p.currentBet === this.gameState.currentBet || p.isAllIn
                );
                
                return allActed && allEqualized;
            }

            async advanceGame() {
                switch (this.gameState.round) {
                    case 'preflop':
                        await this.dealCommunityCards(3); // Flop
                        this.gameState.round = 'flop';
                        break;
                        
                    case 'flop':
                        await this.dealCommunityCards(1); // Turn
                        this.gameState.round = 'turn';
                        break;
                        
                    case 'turn':
                        await this.dealCommunityCards(1); // River
                        this.gameState.round = 'river';
                        break;
                        
                    case 'river':
                        await this.showdown();
                        return;
                }
                
                // Reset for new betting round
                this.gameState.currentBet = 0;
                this.gameState.players.forEach(player => {
                    player.currentBet = 0;
                    player.hasActed = false;
                });
                
                // Set first player (small blind if still active, otherwise next active player)
                const sbPos = (this.gameState.dealerPosition + 1) % 5;
                let firstPlayerPos = sbPos;
                
                for (let i = 0; i < 5; i++) {
                    const player = this.gameState.players[firstPlayerPos];
                    if (player.isActive && !player.isFolded && !player.isAllIn) {
                        break;
                    }
                    firstPlayerPos = (firstPlayerPos + 1) % 5;
                }
                
                this.gameState.currentPlayer = this.gameState.players[firstPlayerPos].id;
                this.gameState.currentBet = 0;
                
                this.updateAllDisplays();
                this.startBettingRound();
            }

            async dealCommunityCards(count) {
                this.showGameState(`Dealing ${count} community card${count > 1 ? 's' : ''}...`);
                
                for (let i = 0; i < count; i++) {
                    await this.sleep(800);
                    const card = this.gameState.deck.pop();
                    this.gameState.communityCards.push(card);
                    this.updateCommunityCardsDisplay();
                    this.animateCommunityCard();
                }
                
                this.hideGameState();
            }

            // ===== SHOWDOWN =====
            async showdown() {
                this.showGameState('Showdown! Determining winner...');
                
                // Calculate rake
                const rake = Math.min(
                    this.gameState.pot * this.gameConfig.rakePercentage,
                    this.gameConfig.maxRake
                );
                this.gameState.rake = rake;
                
                // Determine winner based on 10% win rate for human
                const humanPlayer = this.gameState.players.find(p => p.id === this.playerId);
                const humanWins = Math.random() < this.gameConfig.winRate;
                
                let winners = [];
                
                if (humanWins && humanPlayer && !humanPlayer.isFolded) {
                    // Human wins
                    winners = [humanPlayer];
                    this.session.handsWon++;
                    this.session.netProfit += this.gameState.pot - rake;
                    
                    // Update balance via Cloud Function
                    await this.processWin(humanPlayer, this.gameState.pot - rake);
                    
                    this.showToast(`${humanPlayer.name} WINS $${this.gameState.pot - rake}!`, 'success');
                    this.logGameEvent('win', `Won $${this.gameState.pot - rake} (rake: $${rake})`);
                } else {
                    // AI wins (random AI that hasn't folded)
                    const activeAIPlayers = this.gameState.players.filter(p => 
                        p.isAI && !p.isFolded && p.isActive
                    );
                    
                    if (activeAIPlayers.length > 0) {
                        const winner = activeAIPlayers[Math.floor(Math.random() * activeAIPlayers.length)];
                        winners = [winner];
                        
                        // Update session stats for human loss
                        this.session.netProfit -= (humanPlayer?.currentBet || 0);
                        
                        this.showToast(`${winner.name} wins the pot!`, 'info');
                        this.logGameEvent('loss', `Lost $${humanPlayer?.currentBet || 0}`);
                    }
                }
                
                // Record winner for leaderboard
                if (winners.length > 0) {
                    const winner = winners[0];
                    await this.recordWin(winner.name, this.gameState.pot - rake);
                }
                
                // Reveal all cards
                await this.revealAllCards();
                
                // Update displays
                this.updateAllDisplays();
                this.updateSessionDisplay();
                
                // Animate pot distribution
                if (winners.length > 0) {
                    this.animatePotWin(winners[0].position);
                }
                
                // Show result
                await this.sleep(3000);
                this.hideGameState();
                
                // Start new hand after delay
                setTimeout(() => {
                    if (humanPlayer?.stack > 0) {
                        this.startNewHand();
                    } else {
                        this.showToast('You are out of chips!', 'warning');
                        this.endSession();
                    }
                }, 2000);
            }

            // ===== WIN/LOSS PROCESSING =====
            async processWin(player, amount) {
                try {
                    // Use Cloud Function for secure balance update
                    const updateBalance = functions.httpsCallable('updatePokerBalance');
                    const result = await updateBalance({
                        amount: amount,
                        gameId: this.gameId,
                        playerId: player.id
                    });
                    
                    if (result.data.success) {
                        this.balance = result.data.newBalance;
                        this.updateBalanceDisplay();
                        
                        // Update player stack
                        player.stack += amount;
                        
                        // Record transaction
                        await this.recordTransaction('win', amount, this.gameId);
                    }
                } catch (error) {
                    console.error('Process win error:', error);
                    this.showToast('Error processing win', 'error');
                }
            }

            async recordTransaction(type, amount, gameId) {
                try {
                    await db.collection('poker_transactions').add({
                        playerId: this.playerId,
                        playerName: this.playerProfile?.name,
                        type: type,
                        amount: amount,
                        gameId: gameId,
                        timestamp: new Date(),
                        balanceBefore: this.balance - amount,
                        balanceAfter: this.balance
                    });
                } catch (error) {
                    console.error('Record transaction error:', error);
                }
            }

            async recordWin(playerName, amount) {
                try {
                    await db.collection('poker_wins').add({
                        player: playerName,
                        amount: amount,
                        timestamp: new Date(),
                        gameId: this.gameId
                    });
                    
                    // Update local winners list
                    this.recentWinners.unshift({
                        player: playerName,
                        amount: amount,
                        timestamp: new Date()
                    });
                    
                    if (this.recentWinners.length > 10) {
                        this.recentWinners.pop();
                    }
                    
                    this.updateWinnersDisplay();
                } catch (error) {
                    console.error('Record win error:', error);
                }
            }

            // ===== UI UPDATES =====
            updateAllDisplays() {
                this.updatePlayerDisplays();
                this.updateCommunityCardsDisplay();
                this.updatePotDisplay();
                this.updateRoundDisplay();
            }

            updatePlayerDisplays() {
                this.gameState.players.forEach((player, index) => {
                    const seat = document.getElementById(`seat${index}`);
                    const nameElement = document.getElementById(`seat${index}Name`);
                    const stackElement = document.getElementById(`seat${index}Stack`);
                    const cardsElement = document.getElementById(`seat${index}Cards`);
                    const statusElement = document.getElementById(`seat${index}Status`);
                    
                    if (!seat || !nameElement || !stackElement) return;
                    
                    // Update basic info
                    nameElement.textContent = player.name;
                    stackElement.textContent = `$${player.stack}`;
                    
                    // Update seat styling
                    seat.classList.remove('active', 'dealer', 'folded', 'allin');
                    
                    if (this.gameState.currentPlayer === player.id) {
                        seat.classList.add('active');
                    }
                    
                    if (index === this.gameState.dealerPosition) {
                        seat.classList.add('dealer');
                    }
                    
                    if (player.isFolded) {
                        seat.classList.add('folded');
                    }
                    
                    if (player.isAllIn) {
                        seat.classList.add('allin');
                    }
                    
                    // Update cards
                    if (cardsElement) {
                        cardsElement.innerHTML = '';
                        player.cards.forEach(card => {
                            const cardElement = this.createCardElement(card, !player.isAI || this.gameState.status === 'showdown');
                            cardsElement.appendChild(cardElement);
                        });
                    }
                    
                    // Update status
                    if (statusElement) {
                        statusElement.className = 'player-status';
                        statusElement.textContent = '';
                        
                        if (player.isFolded) {
                            statusElement.classList.add('folded');
                            statusElement.textContent = 'Folded';
                        } else if (player.isAllIn) {
                            statusElement.classList.add('allin');
                            statusElement.textContent = 'All-In';
                        } else if (player.currentBet > 0) {
                            statusElement.classList.add('bet');
                            statusElement.textContent = `Bet: $${player.currentBet}`;
                        }
                    }
                });
            }

            updateCommunityCardsDisplay() {
                const container = document.getElementById('communityCards');
                if (!container) return;
                
                container.innerHTML = '';
                
                this.gameState.communityCards.forEach(card => {
                    const cardElement = this.createCardElement(card, true);
                    container.appendChild(cardElement);
                });
                
                // Add placeholders for remaining cards
                const remaining = 5 - this.gameState.communityCards.length;
                for (let i = 0; i < remaining; i++) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'card back';
                    placeholder.innerHTML = '?';
                    container.appendChild(placeholder);
                }
            }

            updatePotDisplay() {
                const element = document.getElementById('potDisplay');
                if (element) {
                    element.textContent = `Pot: $${this.gameState.pot}`;
                }
            }

            updateRoundDisplay() {
                const element = document.getElementById('roundDisplay');
                if (element) {
                    element.textContent = this.gameState.round.charAt(0).toUpperCase() + 
                                         this.gameState.round.slice(1).replace('flop', 'Flop');
                }
            }

            updateSessionDisplay() {
                const winRate = this.session.handsPlayed > 0 ? 
                    Math.round((this.session.handsWon / this.session.handsPlayed) * 100) : 0;
                
                document.getElementById('winRate').textContent = `${winRate}%`;
                document.getElementById('totalHands').textContent = this.session.handsPlayed;
                document.getElementById('netProfit').textContent = `$${this.session.netProfit}`;
            }

            createCardElement(card, showFront = true) {
                const div = document.createElement('div');
                
                if (showFront && card) {
                    div.className = `card ${card.color} card-deal`;
                    div.innerHTML = `
                        <div class="card-corner card-corner-top">${card.rank}</div>
                        <div class="card-center">${card.suit}</div>
                        <div class="card-corner card-corner-bottom">${card.rank}</div>
                    `;
                } else {
                    div.className = 'card back';
                }
                
                return div;
            }

            // ===== ANIMATIONS =====
            animateCardDeal(playerPosition) {
                const seat = document.getElementById(`seat${playerPosition}`);
                if (seat) {
                    const cards = seat.querySelector('.player-cards');
                    if (cards) {
                        cards.classList.add('card-deal');
                        setTimeout(() => cards.classList.remove('card-deal'), 600);
                    }
                }
            }

            animateCommunityCard() {
                const container = document.getElementById('communityCards');
                if (container) {
                    const lastCard = container.lastElementChild;
                    if (lastCard) {
                        lastCard.classList.add('card-deal');
                    }
                }
            }

            animatePotWin(winnerPosition) {
                const potDisplay = document.getElementById('potDisplay');
                if (potDisplay) {
                    potDisplay.classList.add('win-glow');
                    setTimeout(() => potDisplay.classList.remove('win-glow'), 3000);
                }
                
                const winnerSeat = document.getElementById(`seat${winnerPosition}`);
                if (winnerSeat) {
                    winnerSeat.classList.add('win-glow');
                    setTimeout(() => winnerSeat.classList.remove('win-glow'), 3000);
                }
            }

            async revealAllCards() {
                // Reveal all player cards
                this.gameState.players.forEach((player, index) => {
                    const cardsElement = document.getElementById(`seat${index}Cards`);
                    if (cardsElement) {
                        cardsElement.innerHTML = '';
                        player.cards.forEach(card => {
                            const cardElement = this.createCardElement(card, true);
                            cardsElement.appendChild(cardElement);
                        });
                    }
                });
            }

            // ===== SESSION MANAGEMENT =====
            startSessionTimer() {
                this.session.startTime = new Date();
                setInterval(() => {
                    if (this.session.startTime) {
                        const elapsed = Math.floor((new Date() - this.session.startTime) / 1000);
                        const minutes = Math.floor(elapsed / 60);
                        const seconds = elapsed % 60;
                        document.getElementById('sessionTime').textContent = 
                            `${minutes}m ${seconds}s`;
                    }
                }, 1000);
            }

            async getDailyStats() {
                try {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    
                    const snapshot = await db.collection('poker_sessions')
                        .where('playerId', '==', this.playerId)
                        .where('date', '>=', today)
                        .get();
                    
                    let handsPlayed = 0;
                    let dailyLoss = 0;
                    
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        handsPlayed += data.handsPlayed || 0;
                        if (data.netProfit < 0) {
                            dailyLoss += Math.abs(data.netProfit);
                        }
                    });
                    
                    return { handsPlayed, dailyLoss };
                } catch (error) {
                    console.error('Error getting daily stats:', error);
                    return { handsPlayed: 0, dailyLoss: 0 };
                }
            }

            async endSession() {
                try {
                    // Record session
                    await db.collection('poker_sessions').add({
                        playerId: this.playerId,
                        playerName: this.playerProfile?.name,
                        startTime: this.session.startTime,
                        endTime: new Date(),
                        handsPlayed: this.session.handsPlayed,
                        handsWon: this.session.handsWon,
                        netProfit: this.session.netProfit,
                        date: new Date()
                    });
                    
                    this.showToast('Session ended', 'info');
                    this.logGameEvent('session_end', `Session ended: ${this.session.handsPlayed} hands, $${this.session.netProfit} profit`);
                    
                    // Reset session
                    this.session = {
                        startTime: null,
                        handsPlayed: 0,
                        handsWon: 0,
                        netProfit: 0,
                        dailyLimit: 100,
                        dailyLossLimit: 1000,
                        lastActionTime: null
                    };
                    
                    // Hide action controls
                    document.getElementById('actionControls').style.display = 'none';
                    
                } catch (error) {
                    console.error('Error ending session:', error);
                }
            }

            // ===== EVENT LOGGING =====
            logGameEvent(type, message) {
                console.log(`[Poker] ${type}: ${message}`);
                
                // Add to game history
                const timestamp = new Date();
                this.gameHistory.unshift({
                    timestamp: timestamp,
                    type: type,
                    message: message,
                    result: type === 'win' ? 'win' : 'info'
                });
                
                if (this.gameHistory.length > 20) {
                    this.gameHistory.pop();
                }
                
                this.updateHistoryDisplay();
            }

            logGameAction(player, action, amount) {
                this.logGameEvent('action', `${player.name} ${action}${amount > 0 ? ` $${amount}` : ''}`);
            }

            // ===== UTILITY FUNCTIONS =====
            showToast(message, type = 'info') {
                const container = document.getElementById('toastContainer');
                if (!container) return;
                
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                
                const icons = {
                    success: 'fa-check-circle',
                    error: 'fa-exclamation-circle',
                    warning: 'fa-exclamation-triangle',
                    info: 'fa-info-circle'
                };
                
                toast.innerHTML = `
                    <i class="fas ${icons[type] || 'fa-info-circle'}"></i>
                    <span>${message}</span>
                `;
                
                container.appendChild(toast);
                
                setTimeout(() => toast.classList.add('show'), 10);
                
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (container.contains(toast)) {
                            container.removeChild(toast);
                        }
                    }, 300);
                }, 3000);
            }

            showGameState(message) {
                const overlay = document.getElementById('gameStateOverlay');
                const messageElement = document.getElementById('stateMessage');
                
                if (overlay && messageElement) {
                    messageElement.innerHTML = `
                        <h3>${message}</h3>
                        <p>Please wait...</p>
                        <div class="spinner" style="margin: 20px auto;"></div>
                    `;
                    overlay.style.display = 'flex';
                }
            }

            hideGameState() {
                const overlay = document.getElementById('gameStateOverlay');
                if (overlay) {
                    overlay.style.display = 'none';
                }
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            formatTime(date) {
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }

            // ===== EVENT LISTENERS =====
            setupEventListeners() {
                // Player form
                document.getElementById('playerForm').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.joinGame();
                });

                // Action buttons
                document.getElementById('btnFold').addEventListener('click', () => this.playerAction('fold'));
                document.getElementById('btnCheck').addEventListener('click', () => this.playerAction('check'));
                document.getElementById('btnCall').addEventListener('click', () => this.playerAction('call'));
                document.getElementById('btnRaise').addEventListener('click', () => this.playerAction('raise'));
                document.getElementById('btnAllIn').addEventListener('click', () => this.playerAction('allin'));

                // Chip buttons
                document.querySelectorAll('.chip').forEach(chip => {
                    chip.addEventListener('click', () => {
                        const amount = parseInt(chip.dataset.amount);
                        const currentBet = parseInt(document.getElementById('betAmount').value) || 0;
                        document.getElementById('betAmount').value = currentBet + amount;
                        
                        // Animate chip
                        chip.classList.add('chip-animation');
                        setTimeout(() => chip.classList.remove('chip-animation'), 1000);
                    });
                });

                // Bet input validation
                document.getElementById('betAmount').addEventListener('input', (e) => {
                    const player = this.getCurrentPlayer();
                    if (player && !player.isAI) {
                        const maxBet = player.stack;
                        const value = parseInt(e.target.value) || 0;
                        if (value > maxBet) {
                            e.target.value = maxBet;
                        }
                    }
                });
            }

            // ===== CONNECTION MONITORING =====
            setupConnectionMonitoring() {
                // Monitor Firebase connection
                db.enableNetwork()
                    .then(() => {
                        this.connectionStatus = 'connected';
                        this.updateConnectionStatus();
                    })
                    .catch(error => {
                        this.connectionStatus = 'disconnected';
                        this.updateConnectionStatus();
                    });

                // Network status listener
                window.addEventListener('online', () => {
                    this.connectionStatus = 'connected';
                    this.updateConnectionStatus();
                    this.showToast('Connection restored', 'success');
                });

                window.addEventListener('offline', () => {
                    this.connectionStatus = 'disconnected';
                    this.updateConnectionStatus();
                    this.showToast('Connection lost', 'error');
                });
            }

            updateConnectionStatus() {
                const element = document.getElementById('connectionStatus');
                if (element) {
                    element.className = `connection-status status-${this.connectionStatus}`;
                    element.innerHTML = `
                        <i class="fas fa-${this.connectionStatus === 'connected' ? 'wifi' : 'exclamation-triangle'}"></i>
                        <span>${this.connectionStatus === 'connected' ? 'Connected' : 'Disconnected'}</span>
                    `;
                }
            }
        }

        // ===== INITIALIZE GAME =====
        let pokerGame;

        document.addEventListener('DOMContentLoaded', () => {
            pokerGame = new PokerGame();
            pokerGame.init();
            
            // Anti-cheat protection
            Object.freeze(Math.random);
            Object.freeze(Math);
            
            // Disable right-click
            document.addEventListener('contextmenu', (e) => {
                if (e.target.closest('.card, .player-seat, .action-controls')) {
                    e.preventDefault();
                }
            });
            
            // Prevent F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
            document.addEventListener('keydown', (e) => {
                if (
                    e.key === 'F12' ||
                    (e.ctrlKey && e.shiftKey && ['I', 'J', 'C'].includes(e.key)) ||
                    (e.ctrlKey && e.key === 'u')
                ) {
                    e.preventDefault();
                    pokerGame.showToast('Developer tools are disabled for security', 'warning');
                }
            });
        });

        // ===== CLOUD FUNCTIONS (Server-side logic) =====
        // These would be deployed separately in Firebase Cloud Functions
        /*
        // functions/index.js
        const functions = require('firebase-functions');
        const admin = require('firebase-admin');
        admin.initializeApp();
        
        exports.deductPokerBuyIn = functions.https.onCall(async (data, context) => {
            // Verify authentication
            if (!context.auth) {
                throw new functions.https.HttpsError('unauthenticated', 'User not authenticated');
            }
            
            const { amount, playerName, gameType } = data;
            const userId = context.auth.uid;
            
            // Validate amount
            if (amount < 1 || amount > 10000) {
                throw new functions.https.HttpsError('invalid-argument', 'Invalid amount');
            }
            
            const db = admin.firestore();
            const walletRef = db.collection('wallets').doc(userId);
            
            return await db.runTransaction(async (transaction) => {
                const walletDoc = await transaction.get(walletRef);
                
                if (!walletDoc.exists) {
                    throw new functions.https.HttpsError('not-found', 'Wallet not found');
                }
                
                const currentBalance = walletDoc.data().balance || 0;
                
                if (currentBalance < amount) {
                    throw new functions.https.HttpsError('failed-precondition', 'Insufficient balance');
                }
                
                // Check daily limits
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                const sessionsQuery = db.collection('poker_sessions')
                    .where('playerId', '==', userId)
                    .where('date', '>=', today);
                
                const sessions = await transaction.get(sessionsQuery);
                
                let dailyHands = 0;
                let dailyLoss = 0;
                
                sessions.forEach(session => {
                    const data = session.data();
                    dailyHands += data.handsPlayed || 0;
                    if (data.netProfit < 0) {
                        dailyLoss += Math.abs(data.netProfit);
                    }
                });
                
                if (dailyHands >= 100) {
                    throw new functions.https.HttpsError('resource-exhausted', 'Daily hand limit reached');
                }
                
                if (dailyLoss >= 1000) {
                    throw new functions.https.HttpsError('resource-exhausted', 'Daily loss limit reached');
                }
                
                // Deduct balance
                const newBalance = currentBalance - amount;
                
                transaction.update(walletRef, {
                    balance: newBalance,
                    updatedAt: admin.firestore.FieldValue.serverTimestamp()
                });
                
                // Record transaction
                transaction.set(db.collection('poker_transactions').doc(), {
                    playerId: userId,
                    playerName: playerName,
                    type: 'buyin',
                    amount: -amount,
                    gameType: gameType,
                    timestamp: admin.firestore.FieldValue.serverTimestamp(),
                    balanceBefore: currentBalance,
                    balanceAfter: newBalance
                });
                
                return {
                    success: true,
                    newBalance: newBalance
                };
            });
        });
        
        exports.updatePokerBalance = functions.https.onCall(async (data, context) => {
            if (!context.auth) {
                throw new functions.https.HttpsError('unauthenticated', 'User not authenticated');
            }
            
            const { amount, gameId, playerId } = data;
            const userId = context.auth.uid;
            
            // Verify player owns this transaction
            if (userId !== playerId) {
                throw new functions.https.HttpsError('permission-denied', 'Unauthorized');
            }
            
            const db = admin.firestore();
            const walletRef = db.collection('wallets').doc(userId);
            
            return await db.runTransaction(async (transaction) => {
                const walletDoc = await transaction.get(walletRef);
                
                if (!walletDoc.exists) {
                    throw new functions.https.HttpsError('not-found', 'Wallet not found');
                }
                
                const currentBalance = walletDoc.data().balance || 0;
                const newBalance = currentBalance + amount;
                
                // Prevent negative balance
                if (newBalance < 0) {
                    throw new functions.https.HttpsError('failed-precondition', 'Balance would go negative');
                }
                
                transaction.update(walletRef, {
                    balance: newBalance,
                    updatedAt: admin.firestore.FieldValue.serverTimestamp()
                });
                
                // Record win
                transaction.set(db.collection('poker_wins').doc(), {
                    playerId: userId,
                    amount: amount,
                    gameId: gameId,
                    timestamp: admin.firestore.FieldValue.serverTimestamp()
                });
                
                // Record game result
                transaction.set(db.collection('poker_games').doc(gameId), {
                    playerId: userId,
                    amount: amount,
                    result: amount > 0 ? 'win' : 'loss',
                    timestamp: admin.firestore.FieldValue.serverTimestamp(),
                    processed: true
                });
                
                return {
                    success: true,
                    newBalance: newBalance
                };
            });
        });
        
        exports.getPokerConfig = functions.https.onCall(async (data, context) => {
            const db = admin.firestore();
            const configDoc = await db.collection('config').doc('poker').get();
            
            if (!configDoc.exists) {
                return {
                    winRate: 0.10,
                    houseEdge: 0.90,
                    minBet: 1,
                    maxBet: 10000,
                    blinds: { small: 1, big: 2 },
                    rakePercentage: 0.05,
                    maxRake: 10
                };
            }
            
            return configDoc.data();
        });
        */
    </script>
</body>
</html>
